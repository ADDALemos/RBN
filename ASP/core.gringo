sign(0;1).
complement(T,S) :- sign(S),sign(T),T!=S.



%Regulators, check if edge is removed
isRegulator(N,V) :- regulator(N,V), not removeRegulator(N,V), not negReapir(N,V).
negReapir(N,V):- repaired(N,V), not functionNot(N,_).
removeRegulator(N,V) :- function(N,U), repair(rEdge(V,U)), not functionNot(N,_).
removeRegulator(N,V) :- function(N,U), removeEdge(V,U), not functionNot(N,_).
isRegulator(N,temporary(regulator(N,V))) :- repaired(N,V), not removeRegulator(N,V), not functionNot(N,_).
isRegulator(temporary(regulator(N,V)),V):-repaired(N,V), function(temporary(regulator(N,V)),U), not removeEdge(V,U), not functionNot(N,_).

% Make unreached vertices inputs
input(P,V) :- exp(P), vertex(V), not function(_,V),not edge(U,V) : edge(U,V), U != V.

vlabel(P,V,S,T) :- obs_vlabel(P,V,S,T), exp(P), vertex(V).
%Assign temporary vertex 
vlabel(P,V,S,TI):- vertex(V), exp(P), compute(P,V,S,TI), complement(S,T),not obs_vlabel(P,V,T,TI),timeStep(TI).

%Compute the values
compute(P,O,1,TI):- functionAnd(N,O), noneNegative(O,N,P,TI), vertex(O), exp(P).
compute(P,O,0,TI):- functionAnd(N,O), not noneNegative(O,N,P,TI), vertex(O), exp(P), timeStep(TI).

compute(P,O,1,TI):- functionOr(N,O),not nonePositive(O,N,P,TI), vertex(O), exp(P),timeStep(TI).
compute(P,O,0,TI):- functionOr(N,O),nonePositive(O,N,P,TI), vertex(O), exp(P).

compute(P,O,S,TI):- functionNot(N,O), regulatorSign(P,N,V,T,TI), complement(S,T),vertex(O), exp(P), not removeRegulator(N,V).
compute(P,O,S,TI):- functionId(N,O), regulatorSign(P,N,V,S,TI), vertex(O), exp(P), not removeRegulator(N,V). %identity

compute(P,O,1,TI) :- not function(_,O),vertex(O), exp(P), not compute(P,O,0,TI),timeStep(TI).
compute(P,O,0,TI) :- not function(_,O),vertex(O), exp(P), not compute(P,O,1,TI),timeStep(TI).

compute(P,O,1,0) :- vertex(O), exp(P), not compute(P,O,0,0),timeStep(0).
compute(P,O,0,0) :- vertex(O), exp(P), not compute(P,O,1,0),timeStep(0).

%Verify consistency
consistentFunction(P,O,TI) :- functionAnd(N,O), noneNegative(O,N,P,TI), vlabel(P,O,1,TI), not repair(functionOr(N,O)).
consistentFunction(P,O,TI) :- functionAnd(N,O), not noneNegative(O,N,P,TI), vlabel(P,O,0,TI),not repair(functionOr(N,O)).
consistentFunction(P,O,TI) :- repair(functionAnd(N,O)), noneNegative(O,N,P,TI), vlabel(P,O,_,TI),repairSign(P,O,1,TI), not repair(functionOr(N,O)).
consistentFunction(P,O,TI) :- repair(functionAnd(N,O)), not noneNegative(O,N,P,TI), vlabel(P,O,_,TI),repairSign(P,O,0,TI),not repair(functionOr(N,O)).

consistentFunction(P,O,TI) :- functionOr(N,O), not nonePositive(O,N,P,TI), vlabel(P,O,1,TI), not repair(functionAnd(N,O)).
consistentFunction(P,O,TI) :- functionOr(N,O), nonePositive(O,N,P,TI),vlabel(P,O,0,TI), not repair(functionAnd(N,O)).
consistentFunction(P,O,TI) :- repair(functionOr(N,O)), not nonePositive(O,N,P,TI), repairSign(P,O,1,TI),vlabel(P,O,_,TI), not repair(functionAnd(N,O)).
consistentFunction(P,O,TI) :- repair(functionOr(N,O)), nonePositive(O,N,P,TI),vlabel(P,O,_,TI),repairSign(P,O,0,TI), not repair(functionAnd(N,O)).

consistentFunction(P,O,TI) :- functionNot(N,O),regulatorSign(P,N,O,S,TI),vlabel(P,O,T,TI),S!=T, not repair_functionNot(N,O).
consistentFunction(P,O,TI) :- repair_functionNot(N,O),regulatorSign(P,N,O,S,TI),vlabel(P,O,_,TI),repairSign(P,O,S,TI).
consistentFunction(P,O,TI) :- functionId(N,O),regulatorSign(P,N,O,S,TI),vlabel(P,O,S,TI), not repair_functionNot(N,O).

timeStep(TI):-obs_vlabel(_,_,_,TI). 

%Possible repairs
pos(functionOr(N,O)) :-   repair_g, not obs_vlabel(P,O,_,TI),not nonePositive(O,N,P,TI),not functionOr(N,O),functionAnd(N,O),exp(P),plusinfluence(O),timeStep(TI).  
pos(functionOr(N,O)) :-   repair_g, not obs_vlabel(P,O,_,TI),nonePositive(O,N,P,TI),not functionOr(N,O),functionAnd(N,O),plusinfluence(O).  

pos(functionOr(N,O)) :-   repair_g, obs_vlabel(P,O,1,TI),not nonePositive(O,N,P,TI),not functionOr(N,O),functionAnd(N,O),exp(P),plusinfluence(O).  
pos(functionOr(N,O)) :-   repair_g, obs_vlabel(P,O,0,TI),nonePositive(O,N,P,TI),not functionOr(N,O),functionAnd(N,O),plusinfluence(O).  

pos(functionAnd(N,O)) :-  repair_g, not obs_vlabel(P,O,_,TI),noneNegative(O,N,P,TI),not functionAnd(N,O),functionOr(N,O),plusinfluence(O).  
pos(functionAnd(N,O)) :-  repair_g, not obs_vlabel(P,O,_,TI),not noneNegative(O,N,P,TI),not functionAnd(N,O),functionOr(N,O),exp(P),plusinfluence(O),timeStep(TI).  

pos(functionAnd(N,O)) :-  repair_g, obs_vlabel(P,O,1,TI),noneNegative(O,N,P,TI),not functionAnd(N,O),functionOr(N,O),plusinfluence(O).  
pos(functionAnd(N,O)) :-  repair_g, obs_vlabel(P,O,0,TI),not noneNegative(O,N,P,TI),not functionAnd(N,O),functionOr(N,O),exp(P),plusinfluence(O).  


plusinfluence(O):- edge(V,O), edge(W,O), W!=O,W!=V,V!=O, not repair(rEdge(V,O)), not repair(rEdge(W,O)),not removeEdge(V,O),not removeEdge(W,O).


pos(rEdge(U,V)) :- repair_e, regulator(N,U), function(N,V), regulator(N,W), not removeEdge(W,V),not isTemp(V), not isTemp(U).
pos(rEdge(U,D)) :- repair_e, regulator(N,U), regulator(N,W), function(N,V),not removeEdge(W,V),isTemp(V),isFunction(V,D), not isTemp(D), not isTemp(U).
removeEdge(U,W):-repair(rEdge(U,D)),regulator(N,U), function(N,W), isTemp(W),isFunction(W,D), not isTemp(D).
removeEdge(U,O):-repair(rEdge(U,D)),regulator(N,U), function(N,O).

pos(regulator(O,V)):- repair_i, regulator(N,V), function(N,O), not isTemp(O), not isTemp(V),not removeRegulator(N,V).
pos(regulator(O,V)):- repair_i, regulator(N,V), function(N,W), isTemp(W),isFunction(W,O), not isTemp(O), not isTemp(V),not removeRegulator(N,V).
isFunction(W,O):-regulator(N,W),function(N,O).
isFunction(W,O):-regulator(N,W),function(N,V),isTemp(V), V!=O,isFunction(V,O).


repaired(N,V):- repair(regulator(O,V)),regulator(N,V), function(N,W), isTemp(W),isFunction(W,O), not isTemp(O).

%Negate regulators
repaired(N,V):-repair(regulator(O,V)),regulator(N,V),function(N,O).

%Check if it is possible to apply it
functionNot(temporary(regulator(N,V)),temporary(regulator(N,V))):-repaired(N,V), not functionNot(N,_).
vertex(temporary(regulator(N,V))):-repaired(N,V), not functionNot(N,_).
edge(temporary(regulator(N,V)),O):- repaired(N,V),function(N,O), not functionNot(N,_).
edge(V,temporary(regulator(N,V))):- repaired(N,V), not functionNot(N,_).
repair_functionNot(N,V):-functionNot(N,V), repaired(N,W),regulator(N,W).

{ repair(R) : pos(R) }.


%Auxiliar functions
%At least one positive and none negative
noneNegative(V,N,P,TI) :- not oneNegative(V,N,P,TI), onePositive(V,N,P,TI).
%At least one negative and none positive
nonePositive(V,N,P,TI) :- oneNegative(V,N,P,TI), not onePositive(V,N,P,TI).
%Time only matters to none temporary nodes.
oneNegative(V,N,P,TI):-oneSign(V,N,P,0,TI-1), not isTemp(V).
oneNegative(V,N,P,TI):-oneSign(V,N,P,0,TI), isTemp(V).
onePositive(V,N,P,TI):-oneSign(V,N,P,1,TI-1), not isTemp(V).
onePositive(V,N,P,TI):-oneSign(V,N,P,1,TI), isTemp(V).
oneSign(V,N,P,S,TI):- function(N,V),isRegulator(N,U), vlabel(P,U,S,TI),not repairSign(P,U,_,TI).
oneSign(V,N,P,S,TI):- function(N,V),isRegulator(N,U), repairSign(P,U,S,TI),vlabel(P,U,_,TI).
regulatorSign(P,N,V,1,TI):- onePositive(V,N,P,TI),timeStep(TI).
regulatorSign(P,N,V,0,TI):- oneNegative(V,N,P,TI),timeStep(TI).
:-repairSign(P,U,S,TI),obs_vlabel(P,U,T,TI),S!=T.
repairSign(P,U,S,TI):-repairSign1(P,U,S,TI), isTemp(U).
repairSign(P,U,S,TI):-repairSign1(P,U,S,TI-1), not isTemp(U).
repairSign1(P,U,1,TI) :- repair(functionOr(N,U)),not nonePositive(U,N,P,TI),exp(P), not repair(functionAnd(N,U)) , not repair_functionNot(N,U),timeStep(TI).
repairSign1(P,U,0,TI) :- repair(functionOr(N,U)), nonePositive(U,N,P,TI),exp(P), not repair(functionAnd(N,U)) , not repair_functionNot(N,U).
repairSign1(P,U,1,TI) :- repair(functionAnd(N,U)), noneNegative(U,N,P,TI), exp(P), not repair(functionOr(N,U)) , not repair_functionNot(N,U).
repairSign1(P,U,0,TI) :- repair(functionAnd(N,U)), not noneNegative(U,N,P,TI), exp(P), not repair(functionOr(N,U)) , not repair_functionNot(N,U),timeStep(TI).
repairSign1(P,U,S,TI) :- repair_functionNot(N,U), functionNot(N,U),isRegulator(N,V),vlabel(P,V,S,TI),exp(P), not repair(functionAnd(N,U)) , not repair(functionOr(N,U)).

function(N,V) :- functionOr(N,V).
function(N,V) :- functionAnd(N,V).
function(N,V) :- functionNot(N,V).
function(N,V) :- functionId(N,V).

:- vlabel(P,V,S,TI), not input(P,V), not consistentFunction(P,V,TI), not TI=0.

#minimize { 1, R:repair(R) }.

#show repair/1.
vertex(V):-edge(V,_).
vertex(V):-edge(_,V).
isTemp(temporary(V)):-vertex(temporary(V)).


eq(P,V,T0,T1):-vlabel(P,V,S,T0),vlabel(P,V,S,T1).
:-eq(P,V,T0,T1),timeStep(T0),timeStep(T1),vertex(V),exp(P).